package main

import (
	"embed"
	"flag"
	"html/template"
	"io"
	"io/fs"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/olivere/vite"
)

//go:embed all:dist
var dist embed.FS

//go:embed all:public
var public embed.FS

func main() {
	isDev := flag.Bool("dev", false, "run in development mode")
	flag.Parse()

	mux := http.NewServeMux()

	var appFS, publicFS fs.FS
	if *isDev {
		appFS = os.DirFS(".")
		publicFS = os.DirFS("./public")
	} else {
		distFS, err := fs.Sub(dist, "dist")
		if err != nil {
			log.Fatalf("creating sub-filesystem for 'dist' directory: %v", err)
		}
		appFS = distFS

		publicSub, err := fs.Sub(public, "public")
		if err != nil {
			log.Fatalf("creating sub-filesystem for 'public' directory: %v", err)
		}
		publicFS = publicSub
	}

	// Register the endpoints that get served by the backend.
	mux.HandleFunc("/api/dadjoke", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		// Call https://icanhazdadjoke.com/ API to get a random dad joke.
		// This is just an example, you can replace this with any other API.
		// See https://icanhazdadjoke.com/api for more information.
		req, _ := http.NewRequest("GET", "https://icanhazdadjoke.com/", nil)
		req.Header.Set("Accept", "application/json")
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			http.Error(w, "Error fetching dad joke", http.StatusInternalServerError)
			return
		}
		defer resp.Body.Close()

		w.WriteHeader(resp.StatusCode)
		io.Copy(w, resp.Body)
	})

	// Handle requests for Vite-managed assets.
	mux.Handle("/assets/", http.FileServerFS(appFS))

	// Register the endpoints that get served by the frontend.
	fePaths := []string{
		"/",
		"/index.html",
		"/dadjoke",
		"/about",
	}
	feHandler := FrontendHandler(*isDev, appFS, publicFS, fePaths...)
	for _, page := range fePaths {
		mux.HandleFunc(page, feHandler)
	}

	// Start the server.
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}

	log.Print("Open browser at http://localhost:8080")

	if err := server.ListenAndServe(); err != nil {
		panic(err)
	}
}

func FrontendHandler(isDev bool, appFS, publicFS fs.FS, paths ...string) http.HandlerFunc {
	viteConfig := vite.Config{
		FS:           appFS,
		IsDev:        isDev,
		ViteTemplate: vite.React,
	}
	if isDev {
		viteConfig.ViteURL = "http://localhost:5173"
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		for _, path := range paths {
			if r.URL.Path == path {
				viteFragment, err := vite.HTMLFragment(viteConfig)
				if err != nil {
					http.Error(w, "Error instantiating vite fragment", http.StatusInternalServerError)
					return
				}

				tmpl, err := template.New("index").Parse(indexTmpl)
				if err != nil {
					http.Error(w, "Error parsing template", http.StatusInternalServerError)
					return
				}

				if err = tmpl.Execute(w, map[string]interface{}{
					"Title":   "Homepage",
					"Vite":    viteFragment,
					"Scripts": template.HTML(`<script>console.log("Hello from the backend!")</script>`),
				}); err != nil {
					http.Error(w, "Error executing template", http.StatusInternalServerError)
					return
				}
				return
			}
		}

		// Serve the public files generated by Vite. By default, these files are
		// referenced in the DOM with a root-relative URL format (e.g. '/file.ext').
		http.ServeFileFS(w, r, publicFS, filepath.Base(r.URL.Path))
	})
}

var indexTmpl = `<!doctype html>
<html lang="en" class="h-full scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>{{ .Title }}</title>
	{{ .Vite.Tags }}
 </head>
  <body class="min-h-screen antialiased">
    <div id="root"></div>
	{{ .Scripts }}
  </body>
</html>
`
